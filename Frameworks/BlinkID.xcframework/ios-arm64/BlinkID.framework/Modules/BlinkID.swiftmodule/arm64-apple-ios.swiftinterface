// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0 (swiftlang-6.0.0.9.10 clang-1600.0.26.2)
// swift-module-flags: -target arm64-apple-ios15.0 -enable-objc-interop -cxx-interoperability-mode=default -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -module-name BlinkID
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFoundation
@_exported import BlinkID
import CoreData
import CoreMedia
import CryptoKit
import Foundation
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum BarcodeElementKey {
  case documentType
  case standardVersionNumber
  case customerFamilyName
  case customerFirstName
  case customerFullName
  case dateOfBirth
  case sex
  case eyeColor
  case addressStreet
  case addressCity
  case addressJurisdictionCode
  case addressPostalCode
  case fullAddress
  case height
  case heightIn
  case heightCm
  case customerMiddleName
  case hairColor
  case nameSuffix
  case akaFullName
  case akaFamilyName
  case akaGivenName
  case akaSuffixName
  case weightRange
  case weightPounds
  case weightKilograms
  case customerIdNumber
  case familyNameTruncation
  case firstNameTruncation
  case middleNameTruncation
  case placeOfBirth
  case addressStreet2
  case raceEthnicity
  case namePrefix
  case countryIdentification
  case residenceStreetAddress
  case residenceStreetAddress2
  case residenceCity
  case residenceJurisdictionCode
  case residencePostalCode
  case residenceFullAddress
  case under18
  case under19
  case under21
  case socialSecurityNumber
  case akaSocialSecurityNumber
  case akaMiddleName
  case akaPrefixName
  case organDonor
  case veteran
  case akaDateOfBirth
  case issuerIdentificationNumber
  case documentExpirationDate
  case jurisdictionVersionNumber
  case jurisdictionVehicleClass
  case jurisdictionRestrictionCodes
  case jurisdictionEndorsementCodes
  case documentIssueDate
  case federalCommercialVehicleCodes
  case issuingJurisdiction
  case standardVehicleClassification
  case issuingJurisdictionName
  case standardEndorsementCode
  case standardRestrictionCode
  case jurisdictionVehicleClassificationDescription
  case jurisdictionEndorsmentCodeDescription
  case jurisdictionRestrictionCodeDescription
  case inventoryControlNumber
  case cardRevisionDate
  case documentDiscriminator
  case limitedDurationDocument
  case auditInformation
  case complianceType
  case issueTimestamp
  case permitExpirationDate
  case permitIdentifier
  case permitIssueDate
  case numberOfDuplicates
  case hazmatExpirationDate
  case medicalIndicator
  case nonResident
  case uniqueCustomerId
  case dataDiscriminator
  case documentExpirationMonth
  case documentNonexpiring
  case securityVersion
  public static func == (a: BlinkID.BarcodeElementKey, b: BlinkID.BarcodeElementKey) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class BlinkIDSession : Swift.Sendable {
  final public func cancelActiveProcessing()
  final public func resumeActiveProcessing()
  @BlinkID.ProcessingActor final public func process(inputImage: BlinkID.InputImage) -> BlinkID.FrameProcessResult
  @BlinkID.ProcessingActor final public func reset() throws
  @BlinkID.ProcessingActor final public func getResult() -> BlinkID.BlinkIDScanningResult
  @objc deinit
}
@_hasMissingDesignatedInitializers @globalActor public actor ProcessingActor {
  public static var shared: BlinkID.ProcessingActor
  public typealias ActorType = BlinkID.ProcessingActor
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
public enum Country : Swift.String, Swift.Decodable, Swift.Sendable {
  case none
  case albania
  case algeria
  case argentina
  case australia
  case austria
  case azerbaijan
  case bahrain
  case bangladesh
  case belgium
  case bosniaAndHerzegovina
  case brunei
  case bulgaria
  case cambodia
  case canada
  case chile
  case colombia
  case costaRica
  case croatia
  case cyprus
  case czechia
  case denmark
  case dominicanRepublic
  case egypt
  case estonia
  case finland
  case france
  case georgia
  case germany
  case ghana
  case greece
  case guatemala
  case hongKong
  case hungary
  case india
  case indonesia
  case ireland
  case israel
  case italy
  case jordan
  case kazakhstan
  case kenya
  case kosovo
  case kuwait
  case latvia
  case lithuania
  case malaysia
  case maldives
  case malta
  case mauritius
  case mexico
  case morocco
  case netherlands
  case newZealand
  case nigeria
  case pakistan
  case panama
  case paraguay
  case philippines
  case poland
  case portugal
  case puertoRico
  case qatar
  case romania
  case russia
  case saudiArabia
  case serbia
  case singapore
  case slovakia
  case slovenia
  case southAfrica
  case spain
  case sweden
  case switzerland
  case taiwan
  case thailand
  case tunisia
  case turkey
  case uae
  case uganda
  case uk
  case ukraine
  case usa
  case vietnam
  case brazil
  case norway
  case oman
  case ecuador
  case elSalvador
  case sriLanka
  case peru
  case uruguay
  case bahamas
  case bermuda
  case bolivia
  case china
  case europeanUnion
  case haiti
  case honduras
  case iceland
  case japan
  case luxembourg
  case montenegro
  case nicaragua
  case southKorea
  case venezuela
  case afghanistan
  case alandIslands
  case americanSamoa
  case andorra
  case angola
  case anguilla
  case antarctica
  case antiguaAndBarbuda
  case armenia
  case aruba
  case bailiwickOfGuernsey
  case bailiwickOfJersey
  case barbados
  case belarus
  case belize
  case benin
  case bhutan
  case bonaireSaintEustatiusAndSaba
  case botswana
  case bouvetIsland
  case britishIndianOceanTerritory
  case burkinaFaso
  case burundi
  case cameroon
  case capeVerde
  case caribbeanNetherlands
  case caymanIslands
  case centralAfricanRepublic
  case chad
  case christmasIsland
  case cocosIslands
  case comoros
  case congo
  case cookIslands
  case cuba
  case curacao
  case democraticRepublicOfTheCongo
  case djibouti
  case dominica
  case eastTimor
  case equatorialGuinea
  case eritrea
  case ethiopia
  case falklandIslands
  case faroeIslands
  case federatedStatesOfMicronesia
  case fiji
  case frenchGuiana
  case frenchPolynesia
  case frenchSouthernTerritories
  case gabon
  case gambia
  case gibraltar
  case greenland
  case grenada
  case guadeloupe
  case guam
  case guinea
  case guineaBissau
  case guyana
  case heardIslandAndMcdonaldIslands
  case iran
  case iraq
  case isleOfMan
  case ivoryCoast
  case jamaica
  case kiribati
  case kyrgyzstan
  case laos
  case lebanon
  case lesotho
  case liberia
  case libya
  case liechtenstein
  case macau
  case madagascar
  case malawi
  case mali
  case marshallIslands
  case martinique
  case mauritania
  case mayotte
  case moldova
  case monaco
  case mongolia
  case montserrat
  case mozambique
  case myanmar
  case namibia
  case nauru
  case nepal
  case newCaledonia
  case niger
  case niue
  case norfolkIsland
  case northernCyprus
  case northernMarianaIslands
  case northKorea
  case northMacedonia
  case palau
  case palestine
  case papuaNewGuinea
  case pitcairn
  case reunion
  case rwanda
  case saintBarthelemy
  case saintHelenaAscensionAndTristianDaCunha
  case saintKittsAndNevis
  case saintLucia
  case saintMartin
  case saintPierreAndMiquelon
  case saintVincentAndTheGrenadines
  case samoa
  case sanMarino
  case saoTomeAndPrincipe
  case senegal
  case seychelles
  case sierraLeone
  case sintMaarten
  case solomonIslands
  case somalia
  case southGeorgiaAndTheSouthSandwichIslands
  case southSudan
  case sudan
  case suriname
  case svalbardAndJanMayen
  case eswatini
  case syria
  case tajikistan
  case tanzania
  case togo
  case tokelau
  case tonga
  case trinidadAndTobago
  case turkmenistan
  case turksAndCaicosIslands
  case tuvalu
  case unitedStatesMinorOutlyingIslands
  case uzbekistan
  case vanuatu
  case vaticanCity
  case virginIslandsBritish
  case virginIslandsUs
  case wallisAndFutuna
  case westernSahara
  case yemen
  case yugoslavia
  case zambia
  case zimbabwe
  case schengen_area
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum Region : Swift.String, Swift.Decodable, Swift.Sendable {
  case none
  case alabama
  case alaska
  case alberta
  case arizona
  case arkansas
  case australianCapitalTerritory
  case britishColumbia
  case california
  case colorado
  case connecticut
  case delaware
  case districtOfColumbia
  case florida
  case georgia
  case hawaii
  case idaho
  case illinois
  case indiana
  case iowa
  case kansas
  case kentucky
  case louisiana
  case maine
  case manitoba
  case maryland
  case massachusetts
  case michigan
  case minnesota
  case mississippi
  case missouri
  case montana
  case nebraska
  case nevada
  case newBrunswick
  case newHampshire
  case newJersey
  case newMexico
  case newSouthWales
  case newYork
  case northernTerritory
  case northCarolina
  case northDakota
  case novaScotia
  case ohio
  case oklahoma
  case ontario
  case oregon
  case pennsylvania
  case quebec
  case queensland
  case rhodeIsland
  case saskatchewan
  case southAustralia
  case southCarolina
  case southDakota
  case tasmania
  case tennessee
  case texas
  case utah
  case vermont
  case victoria
  case virginia
  case washington
  case westernAustralia
  case westVirginia
  case wisconsin
  case wyoming
  case yukon
  case ciudadDeMexico
  case jalisco
  case newfoundlandAndLabrador
  case nuevoLeon
  case bajaCalifornia
  case chihuahua
  case guanajuato
  case guerrero
  case mexico
  case michoacan
  case newYorkCity
  case tamaulipas
  case veracruz
  case chiapas
  case coahuila
  case durango
  case guerreroCocula
  case guerreroJuchitan
  case guerreroTepecoacuilco
  case guerreroTlacoapa
  case gujarat
  case hidalgo
  case karnataka
  case kerala
  case khyberPakhtunkhwa
  case madhyaPradesh
  case maharashtra
  case morelos
  case nayarit
  case oaxaca
  case puebla
  case punjab
  case queretaro
  case sanLuisPotosi
  case sinaloa
  case sonora
  case tabasco
  case tamilNadu
  case yucatan
  case zacatecas
  case aguascalientes
  case bajaCaliforniaSur
  case campeche
  case colima
  case quintanaRooBenitoJuarez
  case quintanaRoo
  case quintanaRooSolidaridad
  case tlaxcala
  case quintanaRooCozumel
  case saoPaolo
  case rioDeJaneiro
  case rioGrandeDoSul
  case northwestTerritories
  case nunavut
  case princeEdwardIsland
  case distritoFederal
  case maranhao
  case matoGrosso
  case minasGerais
  case para
  case parana
  case pernambuco
  case santaCatarina
  case andhraPradesh
  case ceara
  case goias
  case guerreroAcapulcoDeJuarez
  case haryana
  case sergipe
  case alagoas
  case bangsamoro
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum DocumentType : Swift.String, Swift.Decodable, Swift.Sendable {
  case none
  case consularId
  case dl
  case dlPublicServicesCard
  case employmentPass
  case finCard
  case id
  case multipurposeId
  case myKad
  case myKid
  case myPR
  case myTentera
  case panCard
  case professionalId
  case publicServicesCard
  case residencePermit
  case residentId
  case temporaryResidencePermit
  case voterId
  case workPermit
  case iKad
  case militaryId
  case myKas
  case socialSecurityCard
  case healthInsuranceCard
  case passport
  case sPass
  case addressCard
  case alienId
  case alienPassport
  case greenCard
  case minorsId
  case postalId
  case professionalDl
  case taxId
  case weaponPermit
  case visa
  case borderCrossingCard
  case driverCard
  case globalEntryCard
  case mypolis
  case nexusCard
  case passportCard
  case proofOfAgeCard
  case refugeeId
  case tribalId
  case veteranId
  case citizenshipCertificate
  case myNumberCard
  case consularPassport
  case minorsPassport
  case minorsPublicServicesCard
  case drivingPrivilegeCard
  case asylumRequest
  case driverQualificationCard
  case provisionalDl
  case refugeePassport
  case specialId
  case uniformedServicesId
  case immigrantVisa
  case consularVoterId
  case twicCard
  case exitEntryPermit
  case mainlandTravelPermitTaiwan
  case nbiClearance
  case proofOfRegistration
  case temporaryProtectionPermit
  case afghanCitizenCard
  case eid
  case pass
  case sisId
  case asicCard
  case bidoonCard
  case interimHealthInsuranceCard
  case nonVoterId
  case reciprocalHealthInsuranceCard
  case vehicleRegistration
  case esaadCard
  case registrationCertificate
  case medicalMarijuanaId
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum DetectionStatus : Swift.String, Swift.Decodable, Swift.Sendable {
  case failed
  case success
  case cameraTooFar
  case cameraTooClose
  case cameraAngleTooSteep
  case documentTooCloseToCameraEdge
  case documentPartiallyVisible
  case fallbackSuccess
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ImageAnalysisDetectionStatus : Swift.Int, Swift.Decodable, Swift.Sendable {
  case notAvailable
  case notDetected
  case detected
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum DocumentImageColorStatus : Swift.Int, Swift.Decodable, Swift.Sendable {
  case notAvailable
  case blackAndWhite
  case color
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum DocumentOrientation : Swift.Int, Swift.Decodable, Swift.Sendable {
  case horizontal
  case vertical
  case notAvailable
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum DocumentRotation : Swift.Int, Swift.Decodable, Swift.Sendable {
  case notAvailable
  case zero
  case clockwise90
  case counterClockwise90
  case upsideDown
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct Point : Swift.Sendable {
  public let x: Swift.Int32
  public let y: Swift.Int32
}
public struct Quadrilateral : Swift.Sendable {
  public let upperLeft: BlinkID.Point
  public let upperRight: BlinkID.Point
  public let lowerRight: BlinkID.Point
  public let lowerLeft: BlinkID.Point
}
public enum ImageOrientation : Swift.Sendable {
  case up
  case down
  case left
  case right
  case upMirrored
  case downMirrored
  case leftMirrored
  case rightMirrored
  public static func == (a: BlinkID.ImageOrientation, b: BlinkID.ImageOrientation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct RegionOfInterest {
  public let x: Swift.Float
  public let y: Swift.Float
  public let width: Swift.Float
  public let height: Swift.Float
  public init(x: Swift.Float = 0, y: Swift.Float = 0, width: Swift.Float = 1, height: Swift.Float = 1)
}
public enum CameraFrameVideoOrientation : Swift.Sendable {
  case portrait
  case portraitUpsideDown
  case landscapeRight
  case landscapeLeft
  public static func == (a: BlinkID.CameraFrameVideoOrientation, b: BlinkID.CameraFrameVideoOrientation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraFrame : @unchecked Swift.Sendable {
  public let buffer: BlinkID.MBSampleBufferWrapper
  public let roi: BlinkID.RegionOfInterest
  public let orientation: BlinkID.CameraFrameVideoOrientation
  public init(buffer: BlinkID.MBSampleBufferWrapper, roi: BlinkID.RegionOfInterest = RegionOfInterest(), orientation: BlinkID.CameraFrameVideoOrientation = .portrait)
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
}
final public class InputImage : Swift.Sendable {
  public init(uiImage: UIKit.UIImage, regionOfInterest: BlinkID.RegionOfInterest = RegionOfInterest())
  public init(cameraFrame: BlinkID.CameraFrame)
  @objc deinit
}
public struct BlinkIDSdkSettings : Swift.Sendable, BlinkID.SdkSettings {
  public var licenseKey: Swift.String
  public var licensee: Swift.String?
  public var helloLogEnabled: Swift.Bool
  public var downloadResources: Swift.Bool
  public var resourceDownloadUrl: Swift.String
  public var resourceLocalFolder: Swift.String
  public var bundleURL: Foundation.URL?
  public var resourceRequestTimeout: BlinkID.RequestTimeout
  public init(licenseKey: Swift.String, licensee: Swift.String? = nil, helloLogEnabled: Swift.Bool = false, downloadResources: Swift.Bool = true, resourceDownloadUrl: Swift.String = "https://models.cdn.microblink.com/resources", resourceLocalFolder: Swift.String = "MLModels", bundleURL: Foundation.URL? = nil, resourceRequestTimeout: BlinkID.RequestTimeout = .default)
}
@_hasMissingDesignatedInitializers final public class BlinkIDSdk : Swift.Sendable {
  @BlinkID.ProcessingActor final public func createScanningSession(sessionSettings: BlinkID.BlinkIDSessionSettings = BlinkIDSessionSettings()) async throws -> BlinkID.BlinkIDSession
  @BlinkID.ProcessingActor public static func createBlinkIDSdk(withSettings settings: BlinkID.BlinkIDSdkSettings) async throws -> BlinkID.BlinkIDSdk
  public static func refreshLicenseLease() async throws
  @BlinkID.ProcessingActor public static func terminateBlinkIDSdk()
  @BlinkID.ProcessingActor public static func terminateBlinkIDSdkAndDeleteCachedResources()
  @objc deinit
}
public enum InputImageSource : Swift.Sendable {
  case video
  case photo
  public static func == (a: BlinkID.InputImageSource, b: BlinkID.InputImageSource) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ScanningMode : Swift.Sendable {
  case single
  case automatic
  public static func == (a: BlinkID.ScanningMode, b: BlinkID.ScanningMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum DetectionLevel : Swift.Sendable {
  case off
  case low
  case mid
  case high
  public static func == (a: BlinkID.DetectionLevel, b: BlinkID.DetectionLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias DPI = Swift.Int
public struct CroppedImageSettings : Swift.Sendable {
  public var dotsPerInch: BlinkID.DPI
  public var extensionFactor: Swift.Float
  public var returnDocumentImage: Swift.Bool
  public var returnFaceImage: Swift.Bool
  public var returnSignatureImage: Swift.Bool
  public init(dotsPerInch: BlinkID.DPI = 250, extensionFactor: Swift.Float = 0, returnDocumentImage: Swift.Bool = false, returnFaceImage: Swift.Bool = false, returnSignatureImage: Swift.Bool = false)
}
public struct DocumentFilter : Swift.Sendable {
  public var country: BlinkID.Country?
  public var region: BlinkID.Region?
  public var documentType: BlinkID.DocumentType?
  public init(country: BlinkID.Country? = nil, region: BlinkID.Region? = nil, documentType: BlinkID.DocumentType? = nil)
}
public struct DocumentNumberAnonymizationSettings : Swift.Sendable {
  public var prefixDigitsVisible: Swift.Int
  public var suffixDigitsVisible: Swift.Int
  public init(prefixDigitsVisible: Swift.Int = 0, suffixDigitsVisible: Swift.Int = 0)
}
public struct DocumentAnonymizationSettings : Swift.Sendable {
  public var documentFilter: BlinkID.DocumentFilter
  public var fields: Swift.Array<BlinkID.FieldType>
  public var documentNumberAnonymizationSettings: BlinkID.DocumentNumberAnonymizationSettings?
  public init(documentFilter: BlinkID.DocumentFilter = DocumentFilter(), fields: Swift.Array<BlinkID.FieldType>, documentNumberAnonymizationSettings: BlinkID.DocumentNumberAnonymizationSettings? = nil)
}
public struct DetailedFieldType : Swift.Sendable {
  public var fieldType: BlinkID.FieldType
  public var alphabetType: BlinkID.AlphabetType
  public init(fieldType: BlinkID.FieldType, alphabetType: BlinkID.AlphabetType)
}
public struct DocumentRules : Swift.Sendable {
  public var documentFilter: BlinkID.DocumentFilter
  public var fields: Swift.Array<BlinkID.DetailedFieldType>
  public init(documentFilter: BlinkID.DocumentFilter = DocumentFilter(), fields: Swift.Array<BlinkID.DetailedFieldType>)
}
@available(swift, deprecated: 7.0, message: "Experimental API, subject to change")
public struct RecognitionModeFilter : Swift.Sendable {
  public var enableMrzId: Swift.Bool
  public var enableMrzVisa: Swift.Bool
  public var enableMrzPassport: Swift.Bool
  public var enablePhotoId: Swift.Bool
  public var enableBarcodeId: Swift.Bool
  public var enableFullDocumentRecognition: Swift.Bool
  public init(enableMrzId: Swift.Bool = true, enableMrzVisa: Swift.Bool = true, enableMrzPassport: Swift.Bool = true, enablePhotoId: Swift.Bool = true, enableBarcodeId: Swift.Bool = true, enableFullDocumentRecognition: Swift.Bool = true)
}
public struct ScanningSettings : Swift.Sendable {
  public var blurDetectionLevel: BlinkID.DetectionLevel
  public var skipImagesWithBlur: Swift.Bool
  public var glareDetectionLevel: BlinkID.DetectionLevel
  public var skipImagesWithGlare: Swift.Bool
  public var tiltDetectionLevel: BlinkID.DetectionLevel
  public var skipImagesWithInadequateLightingConditions: Swift.Bool
  public var skipImagesOccludedByHand: Swift.Bool
  public var combineResultsFromMultipleInputImages: Swift.Bool
  public var enableBarcodeScanOnly: Swift.Bool
  public var customDocumentRules: Swift.Array<BlinkID.DocumentRules>?
  public var anonymizationMode: BlinkID.AnonymizationMode
  public var customDocumentAnonymizationSettings: Swift.Array<BlinkID.DocumentAnonymizationSettings>?
  public var returnInputImages: Swift.Bool
  public var scanCroppedDocumentImage: Swift.Bool
  public var recognitionModeFilter: BlinkID.RecognitionModeFilter
  public var enableCharacterValidation: Swift.Bool
  public var inputImageMargin: Swift.Float
  public var scanUnsupportedBack: Swift.Bool
  public var allowUncertainFrontSideScan: Swift.Bool
  public var maxAllowedMismatchesPerField: Swift.Int
  public var scanPassportDataPageOnly: Swift.Bool
  public var croppedImageSettings: BlinkID.CroppedImageSettings
  public init(blurDetectionLevel: BlinkID.DetectionLevel = .mid, skipImagesWithBlur: Swift.Bool = true, glareDetectionLevel: BlinkID.DetectionLevel = .mid, skipImagesWithGlare: Swift.Bool = true, tiltDetectionLevel: BlinkID.DetectionLevel = .off, skipImagesWithInadequateLightingConditions: Swift.Bool = false, skipImagesOccludedByHand: Swift.Bool = false, combineResultsFromMultipleInputImages: Swift.Bool = true, enableBarcodeScanOnly: Swift.Bool = false, customDocumentRules: Swift.Array<BlinkID.DocumentRules>? = nil, anonymizationMode: BlinkID.AnonymizationMode = .fullResult, customDocumentAnonymizationSettings: Swift.Array<BlinkID.DocumentAnonymizationSettings>? = nil, returnInputImages: Swift.Bool = false, scanCroppedDocumentImage: Swift.Bool = false, enableCharacterValidation: Swift.Bool = true, recognitionModeFilter: BlinkID.RecognitionModeFilter = RecognitionModeFilter(), inputImageMargin: Swift.Float = 0.02, scanUnsupportedBack: Swift.Bool = false, allowUncertainFrontSideScan: Swift.Bool = false, maxAllowedMismatchesPerField: Swift.Int = 0, scanPassportDataPageOnly: Swift.Bool = true, croppedImageSettings: BlinkID.CroppedImageSettings = CroppedImageSettings())
}
public struct BlinkIDSessionSettings : Swift.Sendable {
  public var inputImageSource: BlinkID.InputImageSource
  public var scanningMode: BlinkID.ScanningMode
  public var scanningSettings: BlinkID.ScanningSettings
  public var stepTimeoutDuration: Foundation.TimeInterval
  public init(inputImageSource: BlinkID.InputImageSource = .video, scanningMode: BlinkID.ScanningMode = .automatic, scanningSettings: BlinkID.ScanningSettings = ScanningSettings(), stepTimeoutDuration: Foundation.TimeInterval = 15.0)
}
public struct BlinkIDSDK {
  public struct StringResult : Swift.Sendable {
    public var value: Swift.String? {
      get
    }
    public var location: BlinkID.RectangleF? {
      get
    }
    public var side: BlinkID.ScanningSide? {
      get
    }
    public func value(for alphabetType: BlinkID.AlphabetType) -> Swift.String
    public func side(for alphabetType: BlinkID.AlphabetType) -> BlinkID.ScanningSide?
    public func location(for alphabetType: BlinkID.AlphabetType) -> BlinkID.RectangleF?
  }
  public struct ResultCompleteness : Swift.Sendable {
    public let scanningStatus: BlinkID.ScanningStatus
    public let vizExtracted: Swift.Bool
    public let mrzExtracted: Swift.Bool
    public let barcodeExtracted: Swift.Bool
    public let documentImageExtracted: Swift.Bool
    public let faceImageExtracted: Swift.Bool
    public let signatureImageExtracted: Swift.Bool
  }
  public struct ProcessResult : Swift.Sendable {
    public let inputImageAnalysisResult: BlinkID.InputImageAnalysisResult
    public let resultCompleteness: BlinkID.BlinkIDSDK.ResultCompleteness
  }
  public struct DocumentClassInfo : Swift.Sendable {
    public let country: BlinkID.Country
    public let region: BlinkID.Region
    public let documentType: BlinkID.DocumentType
    public let countryName: Swift.String
    public let isoNumericCountryCode: Swift.String
    public let isoAlpha2CountryCode: Swift.String
    public let isoAlpha3CountryCode: Swift.String
    public func isEmpty() -> Swift.Bool
  }
}
public enum ImageAnalysisLightingStatus : Swift.Sendable {
  case notAvailable
  case tooBright
  case tooDark
  case normal
  public static func == (a: BlinkID.ImageAnalysisLightingStatus, b: BlinkID.ImageAnalysisLightingStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ImageExtractionType : Swift.Sendable {
  case fullDocument
  case face
  case signature
  public static func == (a: BlinkID.ImageExtractionType, b: BlinkID.ImageExtractionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct InputImageAnalysisResult : Swift.Sendable {
  public let processingStatus: BlinkID.ProcessingStatus
  public let missingMandatoryFields: Swift.Array<BlinkID.FieldType>
  public let extractedFields: Swift.Array<BlinkID.FieldType>
  public let invalidCharacterFields: Swift.Array<BlinkID.FieldType>
  public let extraPresentFields: Swift.Array<BlinkID.FieldType>
  public let imageExtractionFailures: Swift.Array<BlinkID.ImageExtractionType>
  public let scanningSide: BlinkID.ScanningSide
  public let documentDetectionStatus: BlinkID.DetectionStatus
  public let documentLocation: BlinkID.Quadrilateral?
  public let documentClassInfo: BlinkID.BlinkIDSDK.DocumentClassInfo
  public let blurDetectionStatus: BlinkID.ImageAnalysisDetectionStatus
  public let glareDetectionStatus: BlinkID.ImageAnalysisDetectionStatus
  public let documentColorStatus: BlinkID.DocumentImageColorStatus
  public let documentMoireStatus: BlinkID.ImageAnalysisDetectionStatus
  public let faceDetectionStatus: BlinkID.ImageAnalysisDetectionStatus
  public let mrzDetectionStatus: BlinkID.ImageAnalysisDetectionStatus
  public let barcodeDetectionStatus: BlinkID.ImageAnalysisDetectionStatus
  public let realIDDetectionStatus: BlinkID.ImageAnalysisDetectionStatus
  public let documentLightingStatus: BlinkID.ImageAnalysisLightingStatus
  public let documentHandOcclusionStatus: BlinkID.ImageAnalysisDetectionStatus
  public let documentOrientation: BlinkID.DocumentOrientation
  public let documentRotation: BlinkID.DocumentRotation
}
public enum ScanningStatus : Swift.Sendable {
  case scanningSideInProgress
  case scanningBarcodeInProgress
  case sideScanned
  case documentScanned
  case cancelled
  public static func == (a: BlinkID.ScanningStatus, b: BlinkID.ScanningStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SessionError : Swift.Error, Swift.Sendable {
  case processCallAfterDocumentScanned
  case resetCallAfterResultRetrieved
  public static func == (a: BlinkID.SessionError, b: BlinkID.SessionError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FrameProcessResult : Swift.Sendable {
  public let processResult: BlinkID.BlinkIDSDK.ProcessResult?
  public let sessionError: BlinkID.SessionError?
}
public struct InvalidLicenseKeyError : Swift.Error {
  public let message: Swift.String
}
public struct MissingResources : Swift.Error {
}
public struct MissingBundle : Swift.Error {
  public let message: Swift.String
}
public enum ResourcesError : Swift.Error, Foundation.LocalizedError {
  case corruptedAssets(Swift.String)
  case resourceDownload(Swift.String)
  case invalidBundle(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
}
public struct ResourceLoadError : Swift.Sendable {
  public let name: Swift.String
  public let error: BlinkID.ModelLoadError
  public init(errors: [(first: Swift.String, second: BlinkID.ModelLoadError)])
}
public enum ModelLoadError : Swift.Sendable, Swift.Error, Foundation.LocalizedError {
  case missingFile
  case invalidFile
  case invalidLicense
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: BlinkID.ModelLoadError, b: BlinkID.ModelLoadError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct MemoryReserveError : Swift.Sendable {
  public let minRequiredMemory: Swift.Int
  public init(minRequiredMemory: Swift.Int)
}
public enum SDKInitError : Swift.Error, Foundation.LocalizedError {
  case resourceLoad(BlinkID.ResourceLoadError)
  case memoryReserve(BlinkID.MemoryReserveError)
  case licenseError
  public var errorDescription: Swift.String? {
    get
  }
}
public enum FieldType : Swift.String, Swift.Decodable, Swift.Sendable, Swift.CaseIterable {
  case additionalAddressInformation
  case additionalNameInformation
  case additionalOptionalAddressInformation
  case additionalPersonalIdNumber
  case address
  case classEffectiveDate
  case classExpiryDate
  case conditions
  case dateOfBirth
  case dateOfExpiry
  case dateOfIssue
  case documentAdditionalNumber
  case documentOptionalAdditionalNumber
  case documentNumber
  case employer
  case endorsements
  case fathersName
  case firstName
  case fullName
  case issuingAuthority
  case lastName
  case licenceType
  case localizedName
  case maritalStatus
  case mothersName
  case mrz
  case nationality
  case personalIdNumber
  case placeOfBirth
  case profession
  case race
  case religion
  case residentialStatus
  case restrictions
  case sex
  case vehicleClass
  case bloodType
  case sponsor
  case visaType
  case documentSubtype
  case remarks
  case residencePermitType
  case manufacturingYear
  case vehicleType
  case dependentDateOfBirth
  case dependentSex
  case dependentDocumentNumber
  case dependentFullName
  case eligibilityCategory
  case specificDocumentValidity
  case vehicleOwner
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias AllCases = [BlinkID.FieldType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [BlinkID.FieldType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public protocol SdkSettings : Swift.Sendable {
  var licenseKey: Swift.String { get set }
  var licensee: Swift.String? { get set }
  var helloLogEnabled: Swift.Bool { get set }
  var downloadResources: Swift.Bool { get set }
  var resourceDownloadUrl: Swift.String { get set }
  var resourceLocalFolder: Swift.String { get set }
  var bundleURL: Foundation.URL? { get set }
  var resourceRequestTimeout: BlinkID.RequestTimeout { get set }
}
public enum MRZDocumentType : Swift.Sendable {
  case unknown
  case identityCard
  case passport
  case visa
  case greenCard
  case mysPassIMM13P
  case driverLicense
  case internalTravelDocument
  case borderCrossingCard
  public static func == (a: BlinkID.MRZDocumentType, b: BlinkID.MRZDocumentType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct VIZResult : Swift.Sendable {
  public let firstName: BlinkID.BlinkIDSDK.StringResult?
  public let lastName: BlinkID.BlinkIDSDK.StringResult?
  public let fullName: BlinkID.BlinkIDSDK.StringResult?
  public let additionalNameInformation: BlinkID.BlinkIDSDK.StringResult?
  public let localizedName: BlinkID.BlinkIDSDK.StringResult?
  public let fathersName: BlinkID.BlinkIDSDK.StringResult?
  public let mothersName: BlinkID.BlinkIDSDK.StringResult?
  public let address: BlinkID.BlinkIDSDK.StringResult?
  public let additionalAddressInformation: BlinkID.BlinkIDSDK.StringResult?
  public let additionalOptionalAddressInformation: BlinkID.BlinkIDSDK.StringResult?
  public let placeOfBirth: BlinkID.BlinkIDSDK.StringResult?
  public let nationality: BlinkID.BlinkIDSDK.StringResult?
  public let race: BlinkID.BlinkIDSDK.StringResult?
  public let religion: BlinkID.BlinkIDSDK.StringResult?
  public let profession: BlinkID.BlinkIDSDK.StringResult?
  public let maritalStatus: BlinkID.BlinkIDSDK.StringResult?
  public let residentialStatus: BlinkID.BlinkIDSDK.StringResult?
  public let employer: BlinkID.BlinkIDSDK.StringResult?
  public let sex: BlinkID.BlinkIDSDK.StringResult?
  public let sponsor: BlinkID.BlinkIDSDK.StringResult?
  public let bloodType: BlinkID.BlinkIDSDK.StringResult?
  public let dateOfBirth: BlinkID.DateResult<BlinkID.BlinkIDSDK.StringResult>?
  public let dateOfIssue: BlinkID.DateResult<BlinkID.BlinkIDSDK.StringResult>?
  public let dateOfExpiry: BlinkID.DateResult<BlinkID.BlinkIDSDK.StringResult>?
  public let dateOfExpiryPermanent: Swift.Bool
  public let documentNumber: BlinkID.BlinkIDSDK.StringResult?
  public let personalIdNumber: BlinkID.BlinkIDSDK.StringResult?
  public let documentAdditionalNumber: BlinkID.BlinkIDSDK.StringResult?
  public let documentOptionalAdditionalNumber: BlinkID.BlinkIDSDK.StringResult?
  public let additionalPersonalIdNumber: BlinkID.BlinkIDSDK.StringResult?
  public let issuingAuthority: BlinkID.BlinkIDSDK.StringResult?
  public let visaType: BlinkID.BlinkIDSDK.StringResult?
  public let driverLicenseDetailedInfo: BlinkID.DriverLicenseDetailedInfo<BlinkID.BlinkIDSDK.StringResult>?
  public let documentSubtype: BlinkID.BlinkIDSDK.StringResult?
  public let remarks: BlinkID.BlinkIDSDK.StringResult?
  public let residencePermitType: BlinkID.BlinkIDSDK.StringResult?
  public let manufacturingYear: BlinkID.BlinkIDSDK.StringResult?
  public let vehicleType: BlinkID.BlinkIDSDK.StringResult?
  public let eligibilityCategory: BlinkID.BlinkIDSDK.StringResult?
  public let specificDocumentValidity: BlinkID.BlinkIDSDK.StringResult?
  public let dependentsInfo: Swift.Array<BlinkID.DependentInfo>
  public let vehicleOwner: BlinkID.BlinkIDSDK.StringResult?
}
public struct MRZResult : Swift.Sendable {
  public let rawMRZString: Swift.String
  public let documentCode: Swift.String
  public let issuer: Swift.String
  public let documentNumber: Swift.String
  public let opt1: Swift.String
  public let opt2: Swift.String
  public let gender: Swift.String
  public let nationality: Swift.String
  public let primaryID: Swift.String
  public let secondaryID: Swift.String
  public let issuerName: Swift.String
  public let nationalityName: Swift.String
  public let verified: Swift.Bool
  public let dateOfBirth: BlinkID.DateResult<Swift.String>
  public let dateOfExpiry: BlinkID.DateResult<Swift.String>
  public let documentType: BlinkID.MRZDocumentType
  public let sanitizedOpt1: Swift.String
  public let sanitizedOpt2: Swift.String
  public let sanitizedNationality: Swift.String
  public let sanitizedIssuer: Swift.String
  public let sanitizedDocumentCode: Swift.String
  public let sanitizedDocumentNumber: Swift.String
}
public struct AddressDetailedInfo : Swift.Sendable {
  public let street: Swift.String?
  public let postalCode: Swift.String?
  public let city: Swift.String?
  public let jurisdiction: Swift.String?
}
public enum BarcodeType : Swift.Sendable {
  case none
  case qrCode
  case dataMatrix
  case upce
  case upca
  case ean8
  case ean13
  case code128
  case code39
  case itf
  case aztec
  case pdf417
  public static func == (a: BlinkID.BarcodeType, b: BlinkID.BarcodeType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct BarcodeData : Swift.Sendable {
  public let rawData: Foundation.Data
  public let stringData: Swift.String
  public let barcodeType: BlinkID.BarcodeType
  public let uncertain: Swift.Bool
}
public struct BarcodeElements : Swift.Sendable {
  public mutating func getValue(for barcodeElementKey: BlinkID.BarcodeElementKey) -> Swift.String
}
public struct BarcodeResult : Swift.Sendable {
  public let barcodeData: BlinkID.BarcodeData
  public let firstName: Swift.String
  public let middleName: Swift.String
  public let lastName: Swift.String
  public let fullName: Swift.String
  public let additionalNameInformation: Swift.String
  public let address: Swift.String
  public let placeOfBirth: Swift.String
  public let nationality: Swift.String
  public let race: Swift.String
  public let religion: Swift.String
  public let profession: Swift.String
  public let maritalStatus: Swift.String
  public let residentialStatus: Swift.String
  public let employer: Swift.String
  public let sex: Swift.String
  public let dateOfBirth: BlinkID.DateResult<Swift.String>
  public let dateOfIssue: BlinkID.DateResult<Swift.String>
  public let dateOfExpiry: BlinkID.DateResult<Swift.String>
  public let documentNumber: Swift.String
  public let personalIdNumber: Swift.String
  public let documentAdditionalNumber: Swift.String
  public let issuingAuthority: Swift.String
  public let addressDetailedInfo: BlinkID.AddressDetailedInfo
  public let driverLicenseDetailedInfo: BlinkID.DriverLicenseDetailedInfo<Swift.String>
  public let extendedElements: BlinkID.BarcodeElements
}
public struct SingleSideScanningResult : Swift.Sendable {
  public var viz: BlinkID.VIZResult?
  public var mrz: BlinkID.MRZResult?
  public var barcode: BlinkID.BarcodeResult?
  public var inputImage: BlinkID.InputImageResult?
  public var barcodeInputImage: BlinkID.InputImageResult?
  public var documentImage: BlinkID.CroppedImageResult?
  public var faceImage: BlinkID.DetailedCroppedImageResult?
  public var signatureImage: BlinkID.DetailedCroppedImageResult?
}
public struct BlinkIDScanningResult : Swift.Sendable {
  public let recognitionMode: BlinkID.RecognitionMode
  public let documentClassInfo: BlinkID.BlinkIDSDK.DocumentClassInfo
  public let dataMatchResult: BlinkID.DataMatchResult?
  public let firstName: BlinkID.BlinkIDSDK.StringResult?
  public let lastName: BlinkID.BlinkIDSDK.StringResult?
  public let fullName: BlinkID.BlinkIDSDK.StringResult?
  public let additionalNameInformation: BlinkID.BlinkIDSDK.StringResult?
  public let localizedName: BlinkID.BlinkIDSDK.StringResult?
  public let fathersName: BlinkID.BlinkIDSDK.StringResult?
  public let mothersName: BlinkID.BlinkIDSDK.StringResult?
  public let address: BlinkID.BlinkIDSDK.StringResult?
  public let additionalAddressInformation: BlinkID.BlinkIDSDK.StringResult?
  public let additionalOptionalAddressInformation: BlinkID.BlinkIDSDK.StringResult?
  public let placeOfBirth: BlinkID.BlinkIDSDK.StringResult?
  public let nationality: BlinkID.BlinkIDSDK.StringResult?
  public let race: BlinkID.BlinkIDSDK.StringResult?
  public let religion: BlinkID.BlinkIDSDK.StringResult?
  public let profession: BlinkID.BlinkIDSDK.StringResult?
  public let maritalStatus: BlinkID.BlinkIDSDK.StringResult?
  public let residentialStatus: BlinkID.BlinkIDSDK.StringResult?
  public let employer: BlinkID.BlinkIDSDK.StringResult?
  public let sex: BlinkID.BlinkIDSDK.StringResult?
  public let sponsor: BlinkID.BlinkIDSDK.StringResult?
  public let bloodType: BlinkID.BlinkIDSDK.StringResult?
  public let documentNumber: BlinkID.BlinkIDSDK.StringResult?
  public let personalIdNumber: BlinkID.BlinkIDSDK.StringResult?
  public let documentAdditionalNumber: BlinkID.BlinkIDSDK.StringResult?
  public let documentOptionalAdditionalNumber: BlinkID.BlinkIDSDK.StringResult?
  public let additionalPersonalIdNumber: BlinkID.BlinkIDSDK.StringResult?
  public let issuingAuthority: BlinkID.BlinkIDSDK.StringResult?
  public let documentSubtype: BlinkID.BlinkIDSDK.StringResult?
  public let remarks: BlinkID.BlinkIDSDK.StringResult?
  public let residencePermitType: BlinkID.BlinkIDSDK.StringResult?
  public let manufacturingYear: BlinkID.BlinkIDSDK.StringResult?
  public let vehicleType: BlinkID.BlinkIDSDK.StringResult?
  public let eligibilityCategory: BlinkID.BlinkIDSDK.StringResult?
  public let specificDocumentValidity: BlinkID.BlinkIDSDK.StringResult?
  public let visaType: BlinkID.BlinkIDSDK.StringResult?
  public let dateOfBirth: BlinkID.DateResult<BlinkID.BlinkIDSDK.StringResult>?
  public let dateOfIssue: BlinkID.DateResult<BlinkID.BlinkIDSDK.StringResult>?
  public let dateOfExpiry: BlinkID.DateResult<BlinkID.BlinkIDSDK.StringResult>?
  public let dateOfExpiryPermanent: Swift.Bool?
  public let driverLicenseDetailedInfo: BlinkID.DriverLicenseDetailedInfo<BlinkID.BlinkIDSDK.StringResult>?
  public let dependentsInfo: Swift.Array<BlinkID.DependentInfo>?
  public let subResults: Swift.Array<BlinkID.SingleSideScanningResult>
  public func getInputImage(scanningSide: BlinkID.ScanningSide) -> BlinkID.InputImageResult?
  public func getBarcodeInputImage() -> BlinkID.InputImageResult?
  public func getDocumentImage(scanningSide: BlinkID.ScanningSide) -> BlinkID.CroppedImageResult?
  public func getFaceImage() -> BlinkID.DetailedCroppedImageResult?
  public func getSignatureImage() -> BlinkID.DetailedCroppedImageResult?
}
public enum AlphabetType : Swift.String, Swift.Sendable, Swift.CaseIterable {
  case latin
  case arabic
  case cyrillic
  case greek
  public init?(rawValue: Swift.String)
  public typealias AllCases = [BlinkID.AlphabetType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [BlinkID.AlphabetType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct RectangleF : Swift.Sendable {
}
public struct DateResult<StringType> : Swift.Sendable where StringType : Swift.Sendable {
  public let day: Swift.Int?
  public let month: Swift.Int?
  public let year: Swift.Int?
  public let date: Foundation.Date?
  public let filledByDomainKnowledge: Swift.Bool
  public let successfullyParsed: Swift.Bool
  public let originalString: StringType
  public func toString() -> Swift.String where StringType == Swift.String
}
public struct RequestTimeout : Swift.Sendable {
  public static let `default`: BlinkID.RequestTimeout
}
public enum ResourceDownloaderError : Foundation.LocalizedError {
  case invalidURL(Swift.String)
  case downloadFailed(Swift.Int)
  case fileNotFound(Foundation.URL)
  case hashMismatch(Swift.String)
  case fileAccessError(any Swift.Error)
  case cacheDirNotFound
  case fileCreationError(any Swift.Error)
  case noInternetConnection
  case invalidResponse
  case resourceUnavailable
  case timedOut
  public var errorDescription: Swift.String? {
    get
  }
}
public enum AnonymizationMode : Swift.String, Swift.Codable, Swift.CaseIterable, Swift.Identifiable, Swift.Sendable {
  case none
  case imageOnly
  case resultFieldsOnly
  case fullResult
  public var id: Swift.String {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias AllCases = [BlinkID.AnonymizationMode]
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ID = Swift.String
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [BlinkID.AnonymizationMode] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum ProcessingStatus : Swift.String, Swift.Decodable, Swift.Sendable {
  case success
  case detectionFailed
  case imagePreprocessingFailed
  case stabilityTestFailed
  case scanningWrongSide
  case fieldIdentificationFailed
  case mandatoryFieldMissing
  case invalidCharactersFound
  case imageReturnFailed
  case barcodeRecognitionFailed
  case mrzParsingFailed
  case documentFiltered
  case unsupportedDocument
  case awaitingOtherSide
  case notScanned
  case barcodeDetectionFailed
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RecognitionMode : Swift.String, Swift.Sendable, Swift.Decodable {
  case none
  case mrzId
  case mrzVisa
  case mrzPassport
  case photoId
  case fullRecognition
  case barcodeId
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct DependentInfo : Swift.Sendable {
  public let dateOfBirth: BlinkID.DateResult<BlinkID.BlinkIDSDK.StringResult>?
  public let sex: BlinkID.BlinkIDSDK.StringResult?
  public let documentNumber: BlinkID.BlinkIDSDK.StringResult?
  public let fullName: BlinkID.BlinkIDSDK.StringResult?
}
public struct VehicleClassInfo<StringType> : Swift.Sendable where StringType : Swift.Sendable {
  public let vehicleClass: StringType?
  public let licenceType: StringType?
  public let effectiveDate: BlinkID.DateResult<StringType>?
  public let expiryDate: BlinkID.DateResult<StringType>?
}
public struct DriverLicenseDetailedInfo<StringType> : Swift.Sendable where StringType : Swift.Sendable {
  public let restrictions: StringType?
  public let endorsements: StringType?
  public let vehicleClass: StringType?
  public let conditions: StringType?
  public let vehicleClassesInfo: Swift.Array<BlinkID.VehicleClassInfo<StringType>>?
}
public protocol InputImageResultProtocol : Swift.Sendable {
  var rawData: Foundation.Data { get }
  var uiImage: UIKit.UIImage? { get }
}
public struct InputImageResult : Swift.Sendable, BlinkID.InputImageResultProtocol {
  public var rawData: Foundation.Data
  public var uiImage: UIKit.UIImage? {
    get
  }
}
public struct CroppedImageResult : Swift.Sendable, BlinkID.InputImageResultProtocol {
  public var rawData: Foundation.Data
  public var uiImage: UIKit.UIImage? {
    get
  }
}
public struct DetailedCroppedImageResult : Swift.Sendable, BlinkID.InputImageResultProtocol {
  public var rawData: Foundation.Data
  public let side: BlinkID.ScanningSide?
  public let location: BlinkID.RectangleF?
  public var uiImage: UIKit.UIImage? {
    get
  }
}
public enum ScanningSide : Swift.Int, Swift.Sendable {
  case first
  case second
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum DataMatchState : Swift.Sendable {
  case notPerformed
  case failed
  case success
  public static func == (a: BlinkID.DataMatchState, b: BlinkID.DataMatchState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum DataMatchFieldType : Swift.Sendable, Swift.CaseIterable {
  case dateOfBirth
  case dateOfExpiry
  case documentNumber
  case documentAdditionalNumber
  case documentOptionalAdditionalNumber
  case personalIdNumber
  public static func == (a: BlinkID.DataMatchFieldType, b: BlinkID.DataMatchFieldType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [BlinkID.DataMatchFieldType]
  nonisolated public static var allCases: [BlinkID.DataMatchFieldType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public struct FieldState : Swift.Sendable {
  public let fieldType: BlinkID.DataMatchFieldType
  public let state: BlinkID.DataMatchState
}
public struct DataMatchResult : Swift.Sendable {
  public let states: Swift.Array<BlinkID.FieldState>
  public let overallState: BlinkID.DataMatchState
  public func getState(for fieldType: BlinkID.DataMatchFieldType) -> BlinkID.DataMatchState
}
extension BlinkID.BarcodeElementKey : Swift.Equatable {}
extension BlinkID.BarcodeElementKey : Swift.Hashable {}
extension BlinkID.ProcessingActor : _Concurrency.GlobalActor {}
extension BlinkID.Country : Swift.Equatable {}
extension BlinkID.Country : Swift.Hashable {}
extension BlinkID.Country : Swift.RawRepresentable {}
extension BlinkID.Region : Swift.Equatable {}
extension BlinkID.Region : Swift.Hashable {}
extension BlinkID.Region : Swift.RawRepresentable {}
extension BlinkID.DocumentType : Swift.Equatable {}
extension BlinkID.DocumentType : Swift.Hashable {}
extension BlinkID.DocumentType : Swift.RawRepresentable {}
extension BlinkID.DetectionStatus : Swift.Equatable {}
extension BlinkID.DetectionStatus : Swift.Hashable {}
extension BlinkID.DetectionStatus : Swift.RawRepresentable {}
extension BlinkID.ImageAnalysisDetectionStatus : Swift.Equatable {}
extension BlinkID.ImageAnalysisDetectionStatus : Swift.Hashable {}
extension BlinkID.ImageAnalysisDetectionStatus : Swift.RawRepresentable {}
extension BlinkID.DocumentImageColorStatus : Swift.Equatable {}
extension BlinkID.DocumentImageColorStatus : Swift.Hashable {}
extension BlinkID.DocumentImageColorStatus : Swift.RawRepresentable {}
extension BlinkID.DocumentOrientation : Swift.Equatable {}
extension BlinkID.DocumentOrientation : Swift.Hashable {}
extension BlinkID.DocumentOrientation : Swift.RawRepresentable {}
extension BlinkID.DocumentRotation : Swift.Equatable {}
extension BlinkID.DocumentRotation : Swift.Hashable {}
extension BlinkID.DocumentRotation : Swift.RawRepresentable {}
extension BlinkID.ImageOrientation : Swift.Equatable {}
extension BlinkID.ImageOrientation : Swift.Hashable {}
extension BlinkID.CameraFrameVideoOrientation : Swift.Equatable {}
extension BlinkID.CameraFrameVideoOrientation : Swift.Hashable {}
extension BlinkID.InputImageSource : Swift.Equatable {}
extension BlinkID.InputImageSource : Swift.Hashable {}
extension BlinkID.ScanningMode : Swift.Equatable {}
extension BlinkID.ScanningMode : Swift.Hashable {}
extension BlinkID.DetectionLevel : Swift.Equatable {}
extension BlinkID.DetectionLevel : Swift.Hashable {}
extension BlinkID.ImageAnalysisLightingStatus : Swift.Equatable {}
extension BlinkID.ImageAnalysisLightingStatus : Swift.Hashable {}
extension BlinkID.ImageExtractionType : Swift.Equatable {}
extension BlinkID.ImageExtractionType : Swift.Hashable {}
extension BlinkID.ScanningStatus : Swift.Equatable {}
extension BlinkID.ScanningStatus : Swift.Hashable {}
extension BlinkID.SessionError : Swift.Equatable {}
extension BlinkID.SessionError : Swift.Hashable {}
extension BlinkID.ModelLoadError : Swift.Equatable {}
extension BlinkID.ModelLoadError : Swift.Hashable {}
extension BlinkID.FieldType : Swift.Equatable {}
extension BlinkID.FieldType : Swift.Hashable {}
extension BlinkID.FieldType : Swift.RawRepresentable {}
extension BlinkID.MRZDocumentType : Swift.Equatable {}
extension BlinkID.MRZDocumentType : Swift.Hashable {}
extension BlinkID.BarcodeType : Swift.Equatable {}
extension BlinkID.BarcodeType : Swift.Hashable {}
extension BlinkID.AlphabetType : Swift.Equatable {}
extension BlinkID.AlphabetType : Swift.Hashable {}
extension BlinkID.AlphabetType : Swift.RawRepresentable {}
extension BlinkID.AnonymizationMode : Swift.Equatable {}
extension BlinkID.AnonymizationMode : Swift.Hashable {}
extension BlinkID.AnonymizationMode : Swift.RawRepresentable {}
extension BlinkID.ProcessingStatus : Swift.Equatable {}
extension BlinkID.ProcessingStatus : Swift.Hashable {}
extension BlinkID.ProcessingStatus : Swift.RawRepresentable {}
extension BlinkID.RecognitionMode : Swift.Equatable {}
extension BlinkID.RecognitionMode : Swift.Hashable {}
extension BlinkID.RecognitionMode : Swift.RawRepresentable {}
extension BlinkID.ScanningSide : Swift.Equatable {}
extension BlinkID.ScanningSide : Swift.Hashable {}
extension BlinkID.ScanningSide : Swift.RawRepresentable {}
extension BlinkID.DataMatchState : Swift.Equatable {}
extension BlinkID.DataMatchState : Swift.Hashable {}
extension BlinkID.DataMatchFieldType : Swift.Equatable {}
extension BlinkID.DataMatchFieldType : Swift.Hashable {}
